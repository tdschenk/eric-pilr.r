{
    "collab_server" : "",
    "contents" : "## Blender data import and processing script\n# Eric Ruud, MEI Research Ltd. eruud@meinergy.com\n\n## Load libraries\nlibrary(jsonlite)\n\n## Define Functions\nderivative <- function(x, data_interval, derivative_window = 8,\n                       average_points = 1) {\n  ## Calculate the number of data points needed to cover the desired\n  ## interval time\n  seconds_in_minute <- 60\n  resolution <- data_interval / seconds_in_minute\n  data_points <- derivative_window / resolution\n\n  ## Create vector to sum the future points\n  f <- rep(0, data_points + 1)\n  ## what if average_points is large?\n  f[1:average_points] <- 1\n  f[(length(f) - average_points + 1) : length(f)] <- -1\n\n  ## Filter the selected Header row using the filter vector\n  ## determined above\n\n  dVector <- stats::filter(x, f) / derivative_window\n  dVector[is.na(dVector)] <- 0\n  dVector\n}\n\n## Define variables\n# Filetype JSON\nfiletype_json <- fromJSON(\"C:\\\\Users\\\\Eric\\\\Dropbox\\\\kfactor\\\\blender-data-file-handler.json\")\n\n# Get the path to the blender file\n# This single select code may be required for non-windows platforms\n# blender_file <- file.choose(new = TRUE)\n\n# select multiple files (may be windows only)\n# blender_files <- choose.files(\"*.csv\")\n# blender_file <- blender_files[1]\nblender_file <- \"C:\\\\Users\\\\Eric\\\\Google Drive\\\\Eric_PILR\\\\blender\\\\Data\\\\UNC_TELEDYNE_200LPM-1-Infusion-160823.csv\"\nblender_files <- c(blender_file)\n\n# Create a filename for export\nexport_file <- paste(strsplit(basename(blender_file),\".csv\"),\"_processed.tsv\",collapse = \"\", sep = \"\")\n\n# Get the column names to the blender file\ncolnames <- read.csv(blender_file, check.names=FALSE, nrows = 1, skip = 1, header = FALSE, stringsAsFactors = FALSE)\n\n## Build the colnames vector to import only columns we want with readcsv\n# We'll loop over each element in the vector of column names to see if we want it\n# If we don't, we'll change it to NULL so that we don't import it\nimportclass <- vector(, length(colnames))\nimportname <- vector(, length(colnames))\nfor (i in 1:length(colnames))\n{\n  for (colname in filetype_json$parser$data_mappings$from_name)\n  {\n    # Check the JSON for the column names\n    if (colname == colnames[i])\n    {\n      importclass[i] <- NA\n      importname[i] <- colnames[i]\n      break\n    }\n    else\n    {\n      importclass[i] <- \"NULL\"\n      importname[i] <- \"NULL\"\n    }\n  }\n}\n\n# import valid columns\nimport <- read.csv(blender_file, check.names=FALSE, skip = 2, stringsAsFactors = FALSE, col.names = importname, colClasses = importclass)\n\n# if multiple files are selected, append to first\n# assume same format for now\nif (length(blender_files)>1)\n{\n  for (i in 2:length(blender_files))\n  {\n    import2 <- read.csv(blender_files[i], check.names=FALSE, skip = 3, stringsAsFactors = FALSE, colClasses = importclass)\n    import[1:nrow(import2)+nrow(import),] <- import2\n  }\n}\n\n\n# Change the date/time to POSIX format\n# Assume format and time column name (CalRQ files)\nimport$Time <- as.POSIXct(import$Time, format = \"%m/%d/%Y %H:%M:%S\")\n\n# Calc a data interval for the derivative\ndata_interval <- median(diff(as.numeric(import$Time)))\n\n# Remove data with BIOSFlow as a NaN since we can't use it\nimport <- import[complete.cases(import$BIOSFlow),]\n\n# We'll try to figure out where the data intervals are now\n# Take the derivative, assume values above the average of the\n# derivative mean the value has switched.\nbiosderiv <- abs(derivative(import$BIOSFlow, data_interval, derivative_window = 2))\n\ncounter <- 0\nbreaks <- 0\nfor (i in 1:length(biosderiv))\n{\n  # Check if deriv is above mean\n  if (biosderiv[i] > mean(biosderiv))\n  {\n    # if it is, add to the counter vector\n    counter <- counter + 1\n  }\n  else\n  {\n    # if it's not above the average, check to see if it was previously, for at least 2 points.\n    if (counter > 1)\n    {\n      # if so, note this breakpoint and zero the counter vector to find the next break\n      breaks <- append(breaks,i-2)\n      counter <- 0\n    }\n  }\n}\n\n# In case we have a negative value in breaks\nbreaks <- breaks[breaks>=0]\n\n# Loop over the data with the breaks we found.\n# Initalize variables\nprocessed = as.data.frame(matrix(ncol=16, nrow=length(breaks) - 1))\nnames(processed) = c(\"BIOSF1\",\"BIOSF2\",\"BIOSF3\",\"BIOSF4\", \"MFC1\", \"MFC2\", \"MFC3\", \"MFC4\", \"MFC1Error\",\"MFC2Error\",\"MFC3Error\",\"MFC4Error\",\"Index1\",\"Index2\",\"Index3\",\"Index4\")\n\nexportdata = as.data.frame(matrix(ncol=6))\nnames(exportdata) = c(\"BIOSF\",\"MFC1\", \"MFC2\", \"MFC3\", \"MFC4\", \"Index\")\n\nfor (i in 1:(length(breaks) - 1))\n{\n  # One subset of data\n  # 4 MFCs may be installed. Find out which was used for this set\n  for (j in 1:4)\n  {\n    # loop over all 4 mfcs, if they != null\n    if (!(is.null(eval(parse(text = paste(\"import$MFCFlow_\",j,sep = \"\"))))))\n    {\n      # Vector exists\n      # Check to see if there was flow for this break\n      # We will see if the values in this section are less than 2% of full scale\n\n      limit <- max(eval(parse(text = paste(\"import$MFCFlow_\",j,sep = \"\"))))*.02\n      bioslimit <- max(import$BIOSFlow)*.02\n\n      section <- eval(parse(text = paste(\"import$MFCFlow_\",j,\"[\",breaks[i],\":\",breaks[i+1],\"]\",sep = \"\")))\n      biossection <- eval(parse(text = paste(\"import$BIOSFlow[\",breaks[i],\":\",breaks[i+1],\"]\",sep = \"\")))\n\n      # Check if this break is above that limit for this MFC\n      # We don't want to analyze the MFC if it's not used for this part\n      # Ignore if mode is under 2% of fullscale\n      if (median(section) > limit)\n      {\n        # this MFC was used for this section\n        # (not used)\n        # MFCName <- paste(\"import$MFCFlow_\",j,sep = \"\",collapse = \"\")\n\n        # Filter to values within 2% of fullscale of median\n        upperlimit <- median(section) + limit\n        lowerlimit <- upperlimit - 2*limit\n        biosupperlimit <- median(biossection) + bioslimit\n        bioslowerlimit <- biosupperlimit - 2*bioslimit\n\n        selection <- (section < upperlimit & section > lowerlimit & biossection < biosupperlimit & biossection > bioslowerlimit)\n\n        # attempt to detect biosmodifier\n        # depending on the instrument biosf might be 1000x mfc read value\n        # compare error and choose what has less error\n        if (abs(mean((section-biossection)/biossection)) < abs(mean((section*1000-biossection)/biossection)))\n        {\n          biosmodifier <- 1\n        } else {\n          biosmodifier <- 1000\n        }\n\n        # correct bios read and assign selected vars\n        biossection <- biossection[selection]/biosmodifier\n        section <- section[selection]\n\n        ## calculate some values\n        # mean of MFC data\n        processed[i,4+j] <- mean(section)\n\n        # error vs. BIOS\n        processed[i,8+j] <- abs(mean((section-biossection)/biossection))\n\n        # mean of BIOSF data that passed our filter\n        processed[i,j] <- mean(biossection)\n\n        offset <- breaks[i]\n        # Build out an array of the data used in calculations\n        if (length(section)>0)\n        {\n        exportdata[1:length(section)+offset,1] <- biossection\n        exportdata[1:length(section)+offset,j+1] <- section\n        exportdata[1:length(section)+offset,6] <- which(selection == TRUE) + offset\n        }\n      }\n    }\n  }\n}\n\n# Build a CSV for export\n# Check to see which MFCs have data then export them\n\n# save avg temp and pressure data once\ntempavg <- mean(import$BIOSTemp, na.rm = TRUE)\npressavg <- mean(import$BIOSBP, na.rm = TRUE)\ncat(c(\"Cal Temp (C)\\tCal Pressure (mmHg)\\tCal Date\\tFilename\\n\",tempavg,\"\\t\",pressavg,\"\\t\",strftime(import$Time[1],\"%D\"),\"\\t\",basename(blender_file),\"\\n\"), file=export_file, append=FALSE)\n\n# in case other files were used\nif (length(blender_files>1))\n{\n  for (i in 2:length(blender_files))\n  cat(c(\"\\t\\t\\t\",basename(blender_files[i]),\"\\n\"), file=export_file, append=TRUE)\n} else\n{\n  cat(c(\"\\n\"), file=export_file, append=TRUE)\n}\n\n# Write our data to a CSV/TSV file\nfor (i in 1:4)\n{\n  # Is there at least one element that is not NA?\n  navalues <- !(is.na(processed[4+i]))\n  # If so, process this MFC\n  if (any(navalues))\n  {\n    # find which values are not NA\n    bios <- subset(processed[i],navalues)\n    mfcflow <- subset(processed[4+i],navalues)\n    error <- subset(processed[8+i],navalues)\n\n    # set rownames to null so ordering references row nums\n    rownames(bios) <- NULL\n    rownames(mfcflow) <- NULL\n    rownames(error) <- NULL\n\n    # sort based on MFCFlow\n    ordering <- unlist(sort(mfcflow[,1], index.return = TRUE)[2])\n    bios <- bios[ordering,1]\n    mfcflow <- mfcflow[ordering,1]\n    error <- error[ordering,1]\n\n    # build a character vector for CalRQ\n    # 6 decmal places, format is MFC1,BIOS1,MFC2,BIOS2, etc\n    for (j in 1:length(mfcflow))\n    {\n      if (j==1)\n      {\n        calstring <- c(sprintf(fmt = \"%.6f\",mfcflow[j]),sprintf(fmt = \"%.6f\",bios[j]))\n      } else\n      {\n        calstring <- append(calstring,c(sprintf(fmt = \"%.6f\",mfcflow[j]),sprintf(fmt = \"%.6f\",bios[j])))\n      }\n\n    }\n\n    # Write out the averages we just calc'd with a header\n    write.table(list(bios,mfcflow,error),file = export_file, row.names = FALSE, append = TRUE, sep = \"\\t\", col.names = c(\"BIOSF\",paste(\"MFCFlow\",i,sep=\"\"),\"Error\"))\n\n    # Write out avg error and the cal string we calc'd\n    cat(c(\"\\tAvg Error (%):\\t\",mean(error),\"\\tCal String:\\t\",paste(calstring,collapse=\",\"),\"\\t\\n\\n\"), file=export_file, append=TRUE)\n\n    ## For CalRQ calibration, we use a 10-point curve\n    # Try to make a 10-point curve if we have more than 10 points\n    if (length(mfcflow) > 10)\n    {\n      targets <- seq(from=min(mfcflow), to=max(mfcflow), length.out = 10)\n\n      # initalize vectors\n      calindex <- vector(,10)\n      for (k in 1:length(targets))\n      {\n        calindex[k] <- which.min(abs(mfcflow-targets[k]))\n      }\n      # Store the data\n      calbios <- bios[calindex]\n      calmfc <- mfcflow[calindex]\n      calerror <- error[calindex]\n\n      # Note that this is a subset of data\n      cat(c(\"10-Point Calibration Subset\\n\"), file=export_file, append=TRUE)\n\n      # Write out the averages we just calc'd with a header\n      write.table(list(calbios,calmfc,calerror),file = export_file, row.names = FALSE, append = TRUE, sep = \"\\t\", col.names = c(\"BIOSF\",paste(\"MFCFlow\",i,sep=\"\"),\"Error\"))\n\n      # build a character vector for CalRQ\n      # 6 decmal places, format is MFC1,BIOS1,MFC2,BIOS2, etc\n      for (j in 1:10)\n      {\n        if (j==1)\n        {\n          calstring <- c(sprintf(fmt = \"%.6f\",calmfc[j]),sprintf(fmt = \"%.6f\",calbios[j]))\n        } else\n        {\n          calstring <- append(calstring,c(sprintf(fmt = \"%.6f\",calmfc[j]),sprintf(fmt = \"%.6f\",calbios[j])))\n        }\n\n      }\n\n      # Write out avg error and the cal string we calc'd\n      cat(c(\"\\tAvg Error (%):\\t\",mean(calerror),\"\\tCal String:\\t\",paste(calstring,collapse=\",\"),\"\\t\\n\\n\"), file=export_file, append=TRUE)\n    }\n\n  }\n}\n\n# Append raw data to TSV\ncat(c(\"Data Used\\n\"), file=export_file, append=TRUE)\nwrite.table(exportdata[!is.na(exportdata$BIOSF),],file = export_file, row.names = FALSE, append = TRUE, sep = \"\\t\", col.names = c(\"BIOSF\",\"MFC1\", \"MFC2\", \"MFC3\", \"MFC4\", \"Index\"))\n",
    "created" : 1472595184592.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1919722119",
    "id" : "919366E9",
    "lastKnownWriteTime" : 1472598442,
    "last_content_update" : 1472598442547,
    "path" : "~/TestPackage/R/blenderprocess.R",
    "project_path" : "R/blenderprocess.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}